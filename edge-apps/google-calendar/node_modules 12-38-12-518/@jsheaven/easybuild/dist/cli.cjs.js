#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var src_exports = {};
__export(src_exports, {
  baseConfig: () => baseConfig,
  buildForBrowser: () => buildForBrowser,
  buildForNode: () => buildForNode,
  debugBuildOptions: () => debugBuildOptions,
  defaultBundleConfigBrowser: () => defaultBundleConfigBrowser,
  defaultBundleConfigNode: () => defaultBundleConfigNode,
  esmDirnamePlugin: () => esmDirnamePlugin,
  formatSize: () => formatSize,
  genericBuild: () => genericBuild,
  genericDefaultBundleConifg: () => genericDefaultBundleConifg,
  getOutfileName: () => getOutfileName,
  getPadLeft: () => getPadLeft,
  getSizeInfo: () => getSizeInfo,
  makeAllPackagesExternalPlugin: () => makeAllPackagesExternalPlugin
});
var import_esbuild, import_path, import_promises, import_path2, import_colors, import_gzip_size, import_brotli_size, import_pretty_bytes, import_fast_glob, import_fs, import_dts_bundle_generator, import_status_message, getPadLeft, formatSize, getSizeInfo, makeAllPackagesExternalPlugin, esmDirnamePlugin, baseConfig, printFileSizes, getOutfileName, debugBuildOptions, genericBuild, genericDefaultBundleConifg, defaultBundleConfigBrowser, defaultBundleConfigNode, buildForBrowser, buildForNode;
var init_src = __esm({
  "src/index.ts"() {
    import_esbuild = require("esbuild");
    import_path = require("path");
    import_promises = require("fs/promises");
    import_path2 = require("path");
    import_colors = require("kleur/colors");
    import_gzip_size = require("gzip-size");
    import_brotli_size = __toESM(require("brotli-size"), 1);
    import_pretty_bytes = __toESM(require("pretty-bytes"), 1);
    import_fast_glob = __toESM(require("fast-glob"), 1);
    import_fs = require("fs");
    import_dts_bundle_generator = require("dts-bundle-generator");
    import_status_message = require("@jsheaven/status-message");
    getPadLeft = (str, width, char = " ") => char.repeat(width - str.length);
    formatSize = (size, filename, type, raw) => {
      const pretty = raw ? `${size} B` : (0, import_pretty_bytes.default)(size);
      const color = size < 5e3 ? import_colors.green : size > 4e4 ? import_colors.red : import_colors.yellow;
      const indent = getPadLeft(pretty, 13);
      return `${indent}${color(pretty)}: ${(0, import_colors.white)((0, import_path2.basename)(filename))}${type ? `.${type}` : ""}`;
    };
    getSizeInfo = async (code, filename, raw) => {
      raw = raw || code.length < 5e3;
      const [gzip, brotli] = await Promise.all([
        (0, import_gzip_size.gzipSize)(code).catch(() => null),
        // @ts-ignore
        import_brotli_size.default.default(code).catch(() => null)
      ]);
      let out = formatSize(gzip, filename, "gz", raw);
      if (brotli) {
        out += "\n" + formatSize(brotli, filename, "br", raw);
      }
      return out;
    };
    makeAllPackagesExternalPlugin = {
      name: "make-all-packages-external",
      setup(build2) {
        let filter = /^[^.\/]|^\.[^.\/]|^\.\.[^\/]/;
        build2.onResolve({ filter }, (args) => ({ path: args.path, external: true }));
      }
    };
    esmDirnamePlugin = {
      name: "esmDirname",
      setup(build2) {
        const nodeModules = new RegExp(/^(?:.*[\\\/])?node_modules(?:[\\\/].*)?$/);
        build2.onLoad({ filter: /.*/ }, async ({ path }) => {
          if (!path.match(nodeModules)) {
            let contents = await (0, import_promises.readFile)(path, "utf8");
            const loader = (0, import_path.extname)(path).substring(1);
            const _dirname = (0, import_path.dirname)(path);
            contents = contents.replaceAll('"/Users/admin/Code/easybundle/src"', `"${_dirname}"`).replaceAll('"/Users/admin/Code/easybundle/src/index.ts"', `"${path}"`);
            return {
              contents,
              loader
            };
          }
        });
      }
    };
    baseConfig = {
      sourcemap: "linked",
      target: "esnext",
      bundle: true,
      minify: true,
      minifySyntax: true,
      minifyIdentifiers: true,
      minifyWhitespace: true,
      legalComments: "none"
    };
    printFileSizes = async (outfile2) => {
      const outfileParsed = (0, import_path2.parse)(outfile2);
      (0, import_status_message.log)("OK", "Find your bundle in", outfileParsed.dir);
      const file = await (0, import_fast_glob.default)(`${outfileParsed.dir}${import_path.sep}${outfileParsed.name}*{js,map,d.ts}`);
      for (let i = 0; i < file.length; i++) {
        const filePath = file[i];
        const code = await (0, import_promises.readFile)(filePath, { encoding: "utf8" });
        if (filePath.endsWith(".js")) {
          console.log(await getSizeInfo(code, filePath, false));
        }
        console.log(formatSize(Buffer.from(code).byteLength, filePath));
      }
    };
    getOutfileName = (fileName, subType) => {
      const fileNameParsed = (0, import_path2.parse)(fileName);
      return `${fileNameParsed.dir}${import_path.sep}${fileNameParsed.name}.${subType}${fileNameParsed.ext}`;
    };
    debugBuildOptions = {
      minify: false,
      minifySyntax: false,
      minifyIdentifiers: false,
      minifyWhitespace: false
    };
    genericBuild = async ({
      outputFormats,
      entryPoint: entryPoint2,
      outfile: outfile2,
      esBuildOptions,
      debug: isDebug,
      dts,
      tsConfigPath,
      dtsLibOptions,
      dtsOutputOptions
    }) => {
      (0, import_status_message.time)("BUNDLED IN");
      if (isDebug) {
        esBuildOptions = {
          ...esBuildOptions,
          ...debugBuildOptions
        };
        (0, import_status_message.debug)(
          "CONFIG",
          "easybundle",
          {
            entryPoint: entryPoint2,
            outfile: outfile2,
            esBuildOptions,
            debug: isDebug,
            dts,
            tsConfigPath,
            dtsLibOptions,
            dtsOutputOptions
          },
          "esbuild plugins",
          esBuildOptions.plugins
        );
      }
      (0, import_status_message.time)("BUILT IN");
      (0, import_status_message.info)("BUILD", "Transpiling", entryPoint2, "...");
      await Promise.all(
        outputFormats.map(
          async (format) => (0, import_esbuild.build)({
            format,
            entryPoints: [entryPoint2],
            outfile: getOutfileName(outfile2, format),
            ...esBuildOptions || {}
          })
        )
      );
      (0, import_status_message.timeEnd)("BUILT IN");
      if (dts) {
        (0, import_status_message.time)("DTS IN");
        (0, import_status_message.info)("DTS", "Generating .d.ts files...");
        try {
          const dTsBundles = (0, import_dts_bundle_generator.generateDtsBundle)(
            [
              {
                filePath: entryPoint2,
                libraries: dtsLibOptions,
                output: dtsOutputOptions
              }
            ],
            { preferredConfigPath: tsConfigPath }
          );
          for (let i = 0; i < outputFormats.length; i++) {
            const format = outputFormats[i];
            const outFileNameParsed = (0, import_path2.parse)(getOutfileName(outfile2, format));
            const declarationOutFile = `${outFileNameParsed.dir}${import_path.sep}${outFileNameParsed.name}.d.ts`;
            (0, import_fs.writeFileSync)(declarationOutFile, dTsBundles[0], { encoding: "utf-8" });
          }
        } catch (e) {
          if (/Symbol for root source file (.*) not found/.test(e.toString())) {
            (0, import_status_message.warn)("DTS", "No type exports found. Skipping.");
          } else {
            (0, import_status_message.error)("DTS", "Error while generating .d.ts files: ", e);
          }
        }
        (0, import_status_message.timeEnd)("DTS IN");
      }
      await printFileSizes(outfile2);
      (0, import_status_message.timeEnd)("BUNDLED IN");
    };
    genericDefaultBundleConifg = {
      outputFormats: ["iife", "esm", "cjs"],
      dts: true,
      tsConfigPath: "tsconfig.json",
      dtsOutputOptions: {
        exportReferencedTypes: true,
        inlineDeclareExternals: true,
        inlineDeclareGlobals: true,
        noBanner: true,
        sortNodes: true
      }
    };
    defaultBundleConfigBrowser = {
      ...genericDefaultBundleConifg,
      esBuildOptions: {
        ...baseConfig,
        platform: "browser",
        plugins: [esmDirnamePlugin]
      }
    };
    defaultBundleConfigNode = {
      ...genericDefaultBundleConifg,
      esBuildOptions: {
        ...baseConfig,
        platform: "node",
        plugins: [esmDirnamePlugin, makeAllPackagesExternalPlugin]
      }
    };
    buildForBrowser = async (config) => genericBuild({
      ...defaultBundleConfigBrowser,
      ...config,
      dtsOutputOptions: {
        ...defaultBundleConfigBrowser.dtsOutputOptions,
        ...config.dtsOutputOptions || {}
      },
      esBuildOptions: {
        ...defaultBundleConfigBrowser.esBuildOptions,
        ...config.esBuildOptions || {}
      }
    });
    buildForNode = async (config) => genericBuild({
      ...defaultBundleConfigNode,
      ...config,
      dtsOutputOptions: {
        ...defaultBundleConfigNode.dtsOutputOptions,
        ...config.dtsOutputOptions || {}
      },
      esBuildOptions: {
        ...defaultBundleConfigNode.esBuildOptions,
        ...config.esBuildOptions || {}
      }
    });
  }
});

// src/cli.ts
var entryPoint = process.argv[2] || "./src/index.ts";
var outfile = process.argv[3] || "./dist/index.js";
var platform = process.argv[4] || "node";
if (platform === "browser") {
  Promise.resolve().then(() => (init_src(), src_exports)).then(
    ({ buildForBrowser: buildForBrowser2 }) => buildForBrowser2({
      entryPoint,
      outfile
    })
  );
} else {
  Promise.resolve().then(() => (init_src(), src_exports)).then(
    ({ buildForNode: buildForNode2 }) => buildForNode2({
      entryPoint,
      outfile
    })
  );
}
//# sourceMappingURL=cli.cjs.js.map
